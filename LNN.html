<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Local Nested Notes</title>
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 32 32'%3E%3Crect width='32' height='32' fill='%23000'/%3E%3Cpath d='M6 8h20v2H6zm2 4h16v2H8zm2 4h12v2h-12zm2 4h8v2h-8z' fill='%23FFA500'/%3E%3C/svg%3E">
    <style>
        :root {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --text-primary: #ffffff;
            --text-secondary: #cccccc;
            --accent-orange: #FFA500;
            --accent-yellow: #FFD700;
            --border: #444444;
            --hover: #3a3a3a;
            --selected: #4a4a4a;
            --mono-font: 'Courier New', 'Monaco', 'Menlo', monospace;
        }

        [data-theme="light"] {
            --bg-primary: #ffffff;
            --bg-secondary: #f5f5f5;
            --text-primary: #000000;
            --text-secondary: #333333;
            --border: #cccccc;
            --hover: #e0e0e0;
            --selected: #d0d0d0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--mono-font);
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
        }

        .app-container {
            display: flex;
            height: 100vh;
        }

        .toolbar {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            padding: 8px 16px;
            display: flex;
            align-items: center;
            gap: 16px;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            height: 48px;
        }

        .toolbar h1 {
            font-size: 16px;
            color: var(--accent-orange);
        }

        .toolbar-buttons {
            display: flex;
            gap: 8px;
        }

        .btn {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border);
            padding: 4px 8px;
            cursor: pointer;
            font-size: 12px;
            font-family: var(--mono-font);
        }

        .btn:hover {
            background: var(--hover);
        }

        .btn.accent {
            background: var(--accent-orange);
            color: black;
        }

        .unsaved-indicator {
            color: var(--accent-yellow);
            font-size: 12px;
        }

        .sidebar {
            width: 300px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            margin-top: 48px;
        }

        .sidebar-header {
            padding: 12px;
            border-bottom: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .sidebar-header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .search-input {
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border);
            padding: 4px 8px;
            font-family: var(--mono-font);
            font-size: 12px;
            width: 100%;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--accent-orange);
        }

        .note-item.search-match {
            background: var(--accent-yellow);
            color: black;
        }

        .note-item.search-dimmed {
            opacity: 0.3;
        }

        .notes-tree {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .note-item {
            display: block;
            padding: 6px 12px;
            cursor: pointer;
            border: 1px solid transparent;
            margin: 2px 0;
            position: relative;
        }

        .note-item:hover {
            background: var(--hover);
        }

        .note-item.selected {
            background: var(--selected);
            border-color: var(--accent-orange);
        }

        .note-item.ctrl-selected {
            background: var(--accent-yellow);
            color: black;
        }

        .note-item.editable {
            background: var(--bg-primary);
            border: 1px solid var(--accent-orange);
        }

        .note-item input {
            background: transparent;
            border: none;
            outline: none;
            font-family: var(--mono-font);
            font-size: inherit;
            color: inherit;
            width: 100%;
        }

        .collapse-toggle {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin-right: 4px;
            cursor: pointer;
            user-select: none;
            font-size: 10px;
            text-align: center;
            line-height: 12px;
        }

        .collapse-toggle:hover {
            color: var(--accent-orange);
        }

        .collapse-toggle.empty {
            visibility: hidden;
        }

        .drop-zone {
            height: 4px;
            background: var(--accent-orange);
            margin: 2px 0;
            border-radius: 2px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .drop-zone.active {
            opacity: 1;
        }

        .note-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            margin-top: 48px;
        }

        .content-header {
            padding: 12px;
            border-bottom: 1px solid var(--border);
            background: var(--bg-secondary);
        }

        .editor-container {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .editor {
            flex: 1;
            display: flex;
            border-right: 1px solid var(--border);
            position: relative;
        }

        .editor:last-child {
            border-right: none;
        }

        .line-numbers {
            background: var(--bg-secondary);
            color: var(--text-secondary);
            padding: 12px 8px;
            font-size: 12px;
            line-height: 1.5;
            user-select: none;
            border-right: 1px solid var(--border);
            overflow: hidden;
            white-space: pre;
            text-align: right;
            min-width: 40px;
        }

        .editor-textarea {
            flex: 1;
            background: var(--bg-primary);
            color: var(--text-primary);
            border: none;
            outline: none;
            padding: 12px;
            font-family: var(--mono-font);
            font-size: 12px;
            line-height: 1.5;
            resize: none;
            white-space: pre-wrap;
        }

        .context-menu {
            position: absolute;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            z-index: 2000;
            min-width: 120px;
        }

        .context-menu-item {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 12px;
        }

        .context-menu-item:hover {
            background: var(--hover);
        }

        .drag-over {
            border: 2px dashed var(--accent-orange) !important;
            background: var(--hover) !important;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }

        .modal-content {
            background: var(--bg-secondary);
            padding: 24px;
            border: 1px solid var(--border);
            min-width: 300px;
        }

        .modal input {
            width: 100%;
            padding: 8px;
            margin: 8px 0;
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border);
            font-family: var(--mono-font);
        }

        @media print {
            .sidebar, .toolbar {
                display: none !important;
            }
            .note-content {
                margin-top: 0 !important;
            }
            .line-numbers {
                background: white !important;
                color: #666 !important;
            }
            .editor-textarea {
                background: white !important;
                color: black !important;
            }
        }

        @media (max-width: 768px) {
            .sidebar {
                width: 250px;
            }
        }
    </style>
</head>
<body data-theme="dark">
    <div class="toolbar">
        <h1>üìù Local Nested Notes</h1>
        <div class="toolbar-buttons">
            <button class="btn" onclick="toggleTheme()">üåì Theme</button>
            <button class="btn" onclick="exportData()">üì§ Export</button>
            <button class="btn" onclick="importData()">üì• Import</button>
            <button class="btn" onclick="printNotes()">üñ®Ô∏è Print</button>
        </div>
        <div class="unsaved-indicator" id="unsaved-indicator" style="display: none;">‚óè Unsaved Changes</div>
    </div>

    <div class="app-container">
        <div class="sidebar">
            <div class="sidebar-header">
                <div class="sidebar-header-top">
                    <span>Notes</span>
                    <button class="btn accent" onclick="addNote()">‚ûï New</button>
                </div>
                <input type="text" class="search-input" id="search-input" placeholder="Search notes..." onkeyup="app.handleSearch(event)">
            </div>
            <div class="notes-tree" id="notes-tree"></div>
        </div>

        <div class="note-content">
            <div class="content-header">
                <span id="content-title">Select a note to edit</span>
            </div>
            <div class="editor-container" id="editor-container">
                <div class="editor">
                    <div class="line-numbers" id="line-numbers-1">1</div>
                    <textarea class="editor-textarea" id="editor-1" placeholder="Select a note to start writing..."></textarea>
                </div>
            </div>
        </div>
    </div>

    <input type="file" id="file-input" style="display: none;" accept=".json">

    <script>
        class NestedNotes {
            constructor() {
                this.notes = {};
                this.selectedNotes = [];
                this.draggedNote = null;
                this.hasUnsavedChanges = false;
                this.nextId = 1;
                this.editingNote = null;
                this.collapsedNodes = new Set();
                this.searchTerm = '';
                this.searchMatches = new Set();
                
                this.initializeData();
                this.bindEvents();
                this.render();
                
                // Warn before page refresh
                window.addEventListener('beforeunload', (e) => {
                    e.preventDefault();
                    e.returnValue = 'You have unsaved changes. Data will be lost on refresh. Are you sure?';
                    return e.returnValue;
                });
            }

            initializeData() {
                // Create initial notes if none exist
                if (Object.keys(this.notes).length === 0) {
                    this.notes = {
                        1: { id: 1, title: 'Welcome', content: 'Welcome to Nested Local Notes!\n\nThis is a portable note-taking app that works entirely in your browser.\n\nFeatures:\n- Create nested notes\n- Drag and drop to reorder\n- Multiple note viewing (Ctrl+click)\n- Dark/light themes\n- Export/import data\n- Print support\n\nTry creating a new note or editing this one!', parent: null, order: 0 },
                        2: { id: 2, title: 'Getting Started', content: 'Getting started is easy:\n\n1. Click the "‚ûï New Note" button to create notes\n2. Right-click notes for more options\n3. Drag notes to reorder them\n4. Ctrl+click to view multiple notes\n5. Use Export/Import to backup your data\n\nRemember: Data is not saved automatically.\nUse Export to save your work!', parent: null, order: 1 }
                    };
                    this.nextId = 3;
                    this.selectedNotes = [1];
                }
            }

            bindEvents() {
                // Context menu
                document.addEventListener('contextmenu', (e) => {
                    const noteItem = e.target.closest('.note-item');
                    if (noteItem) {
                        e.preventDefault();
                        this.showContextMenu(e, parseInt(noteItem.dataset.noteId));
                    }
                });

                // Click outside to close context menu
                document.addEventListener('click', () => {
                    this.hideContextMenu();
                });

                // File input for import
                document.getElementById('file-input').addEventListener('change', (e) => {
                    this.handleFileImport(e.target.files[0]);
                });
            }

            markUnsaved() {
                this.hasUnsavedChanges = true;
                document.getElementById('unsaved-indicator').style.display = 'block';
            }

            markSaved() {
                this.hasUnsavedChanges = false;
                document.getElementById('unsaved-indicator').style.display = 'none';
            }

            addNote(parentId = null) {
                const title = prompt('Enter note title:', `Note ${this.nextId}`);
                if (!title) return;

                const note = {
                    id: this.nextId++,
                    title,
                    content: '',
                    parent: parentId,
                    order: Object.values(this.notes).filter(n => n.parent === parentId).length
                };

                this.notes[note.id] = note;
                this.selectedNotes = [note.id];
                this.markUnsaved();
                this.render();
            }

            deleteNote(noteId) {
                if (!confirm('Delete this note and all its children?')) return;

                // Find and delete children recursively
                const deleteRecursive = (id) => {
                    Object.values(this.notes).filter(n => n.parent === id).forEach(child => {
                        deleteRecursive(child.id);
                    });
                    delete this.notes[id];
                };

                deleteRecursive(noteId);
                this.selectedNotes = this.selectedNotes.filter(id => id !== noteId);
                this.markUnsaved();
                this.render();
            }

            duplicateNote(noteId) {
                const note = this.notes[noteId];
                if (!note) return;

                const newNote = {
                    ...note,
                    id: this.nextId++,
                    title: `${note.title} (Copy)`,
                    order: note.order + 1
                };

                // Adjust order of siblings
                Object.values(this.notes)
                    .filter(n => n.parent === note.parent && n.order > note.order)
                    .forEach(n => n.order++);

                this.notes[newNote.id] = newNote;
                this.markUnsaved();
                this.render();
            }

            renameNote(noteId) {
                const note = this.notes[noteId];
                if (!note) return;

                this.editingNote = noteId;
                this.render();
            }

            finishRename(noteId, newTitle) {
                const note = this.notes[noteId];
                if (note && newTitle && newTitle.trim() !== note.title) {
                    note.title = newTitle.trim();
                    this.markUnsaved();
                }
                this.editingNote = null;
                this.render();
            }

            cancelRename() {
                this.editingNote = null;
                this.render();
            }

            toggleCollapse(noteId) {
                if (this.collapsedNodes.has(noteId)) {
                    this.collapsedNodes.delete(noteId);
                } else {
                    this.collapsedNodes.add(noteId);
                }
                this.render();
            }

            hasChildren(noteId) {
                return Object.values(this.notes).some(note => note.parent === noteId);
            }

            handleSearch(event) {
                this.searchTerm = event.target.value.toLowerCase().trim();
                this.performSearch();
                this.render();
            }

            performSearch() {
                this.searchMatches.clear();
                
                if (!this.searchTerm) {
                    return;
                }

                Object.values(this.notes).forEach(note => {
                    const titleMatch = note.title.toLowerCase().includes(this.searchTerm);
                    const contentMatch = note.content.toLowerCase().includes(this.searchTerm);
                    
                    if (titleMatch || contentMatch) {
                        this.searchMatches.add(note.id);
                        // Auto-expand parent chain for matches
                        this.expandParentChain(note.id);
                    }
                });
            }

            expandParentChain(noteId) {
                const note = this.notes[noteId];
                if (note && note.parent !== null) {
                    this.collapsedNodes.delete(note.parent);
                    this.expandParentChain(note.parent);
                }
            }

            selectNote(noteId, ctrlKey = false) {
                if (ctrlKey) {
                    const index = this.selectedNotes.indexOf(noteId);
                    if (index === -1) {
                        this.selectedNotes.push(noteId);
                    } else {
                        this.selectedNotes.splice(index, 1);
                    }
                } else {
                    this.selectedNotes = [noteId];
                }
                this.render();
            }

            showContextMenu(event, noteId) {
                this.hideContextMenu();

                const menu = document.createElement('div');
                menu.className = 'context-menu';
                menu.style.left = `${event.clientX}px`;
                menu.style.top = `${event.clientY}px`;

                const menuItems = [
                    { text: '‚úèÔ∏è Rename', action: () => this.renameNote(noteId) },
                    { text: 'üìã Duplicate', action: () => this.duplicateNote(noteId) },
                    { text: '‚ûï Add Child', action: () => this.addNote(noteId) },
                    { text: 'üóëÔ∏è Delete', action: () => this.deleteNote(noteId) }
                ];

                menuItems.forEach(item => {
                    const menuItem = document.createElement('div');
                    menuItem.className = 'context-menu-item';
                    menuItem.textContent = item.text;
                    menuItem.onclick = (e) => {
                        e.stopPropagation();
                        item.action();
                        this.hideContextMenu();
                    };
                    menu.appendChild(menuItem);
                });

                document.body.appendChild(menu);
            }

            hideContextMenu() {
                const existing = document.querySelector('.context-menu');
                if (existing) existing.remove();
            }

            updateLineNumbers(textareaId, lineNumbersId) {
                const textarea = document.getElementById(textareaId);
                const lineNumbers = document.getElementById(lineNumbersId);
                
                if (!textarea || !lineNumbers) return;

                const lines = textarea.value.split('\n').length;
                const numbers = Array.from({length: lines}, (_, i) => i + 1).join('\n');
                lineNumbers.textContent = numbers;

                // Sync scroll
                textarea.onscroll = () => {
                    lineNumbers.scrollTop = textarea.scrollTop;
                };
            }

            render() {
                this.renderTree();
                this.renderEditors();
            }

            renderTree() {
                const tree = document.getElementById('notes-tree');
                tree.innerHTML = '';

                const renderNotes = (parentId, level = 0) => {
                    const children = Object.values(this.notes)
                        .filter(note => note.parent === parentId)
                        .sort((a, b) => a.order - b.order);

                    children.forEach((note, index) => {
                        // Add drop zone before first item or between items
                        if (index === 0) {
                            const dropZone = this.createDropZone(parentId, -1, level);
                            tree.appendChild(dropZone);
                        }

                        const item = document.createElement('div');
                        item.className = 'note-item';
                        item.dataset.noteId = note.id;
                        item.style.paddingLeft = `${12 + level * 20}px`;
                        
                        if (this.selectedNotes.includes(note.id)) {
                            if (this.selectedNotes.length > 1) {
                                item.classList.add('ctrl-selected');
                            } else {
                                item.classList.add('selected');
                            }
                        }

                        // Apply search styling
                        if (this.searchTerm) {
                            if (this.searchMatches.has(note.id)) {
                                item.classList.add('search-match');
                            } else {
                                item.classList.add('search-dimmed');
                            }
                        }

                        // Create collapse toggle
                        const toggle = document.createElement('span');
                        toggle.className = 'collapse-toggle';
                        
                        if (this.hasChildren(note.id)) {
                            toggle.textContent = this.collapsedNodes.has(note.id) ? '‚ñ∂' : '‚ñº';
                            toggle.onclick = (e) => {
                                e.stopPropagation();
                                this.toggleCollapse(note.id);
                            };
                        } else {
                            toggle.classList.add('empty');
                        }

                        // Handle inline editing
                        if (this.editingNote === note.id) {
                            item.classList.add('editable');
                            item.appendChild(toggle);
                            const input = document.createElement('input');
                            input.value = note.title;
                            input.onblur = () => this.finishRename(note.id, input.value);
                            input.onkeydown = (e) => {
                                if (e.key === 'Enter') {
                                    this.finishRename(note.id, input.value);
                                } else if (e.key === 'Escape') {
                                    this.cancelRename();
                                }
                            };
                            item.appendChild(input);
                            setTimeout(() => {
                                input.focus();
                                input.select();
                            }, 0);
                        } else {
                            item.appendChild(toggle);
                            const titleSpan = document.createElement('span');
                            titleSpan.textContent = note.title;
                            item.appendChild(titleSpan);
                            
                            // Double click to rename
                            item.ondblclick = (e) => {
                                e.stopPropagation();
                                this.renameNote(note.id);
                            };
                        }

                        // Click events
                        item.onclick = (e) => {
                            if (this.editingNote === note.id) return;
                            if (e.target.classList.contains('collapse-toggle')) return;
                            e.stopPropagation();
                            this.selectNote(note.id, e.ctrlKey || e.metaKey);
                        };

                        // Drag and drop
                        item.draggable = true;
                        item.ondragstart = (e) => {
                            this.draggedNote = note.id;
                            e.dataTransfer.effectAllowed = 'move';
                            item.style.opacity = '0.5';
                        };

                        item.ondragend = () => {
                            item.style.opacity = '';
                            this.clearDropZones();
                        };

                        tree.appendChild(item);

                        // Render children only if not collapsed
                        if (!this.collapsedNodes.has(note.id)) {
                            renderNotes(note.id, level + 1);
                        }

                        // Add drop zone after each item
                        const dropZone = this.createDropZone(parentId, index, level);
                        tree.appendChild(dropZone);
                    });

                    // If no children, add a drop zone for empty parent
                    if (children.length === 0 && parentId !== null) {
                        const dropZone = this.createDropZone(parentId, -1, level);
                        tree.appendChild(dropZone);
                    }
                };

                renderNotes(null);
            }

            createDropZone(parentId, afterIndex, level) {
                const dropZone = document.createElement('div');
                dropZone.className = 'drop-zone';
                dropZone.style.marginLeft = `${12 + level * 20}px`;
                
                dropZone.ondragover = (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    dropZone.classList.add('active');
                };

                dropZone.ondragleave = () => {
                    dropZone.classList.remove('active');
                };

                dropZone.ondrop = (e) => {
                    e.preventDefault();
                    dropZone.classList.remove('active');
                    
                    if (this.draggedNote) {
                        this.moveNoteToPosition(this.draggedNote, parentId, afterIndex);
                        this.draggedNote = null;
                    }
                };

                return dropZone;
            }

            clearDropZones() {
                document.querySelectorAll('.drop-zone').forEach(zone => {
                    zone.classList.remove('active');
                });
            }

            moveNoteToPosition(noteId, newParentId, afterIndex) {
                const note = this.notes[noteId];
                if (!note) return;

                // Don't allow moving a note into its own descendants
                if (this.isDescendant(noteId, newParentId)) return;

                const oldParent = note.parent;
                const oldOrder = note.order;

                // Update orders in old parent
                if (oldParent !== null) {
                    Object.values(this.notes)
                        .filter(n => n.parent === oldParent && n.order > oldOrder)
                        .forEach(n => n.order--);
                }

                // Set new parent and order
                note.parent = newParentId;
                
                // Calculate new order
                const siblings = Object.values(this.notes)
                    .filter(n => n.parent === newParentId && n.id !== noteId)
                    .sort((a, b) => a.order - b.order);

                if (afterIndex === -1) {
                    // Insert at beginning
                    note.order = 0;
                    siblings.forEach(n => n.order++);
                } else {
                    // Insert after specific index
                    const targetOrder = afterIndex + 1;
                    note.order = targetOrder;
                    siblings.filter(n => n.order >= targetOrder).forEach(n => n.order++);
                }

                this.markUnsaved();
                this.render();
            }

            isDescendant(ancestorId, potentialDescendantId) {
                if (potentialDescendantId === null) return false;
                if (potentialDescendantId === ancestorId) return true;
                
                const potentialDescendant = this.notes[potentialDescendantId];
                if (!potentialDescendant) return false;
                
                return this.isDescendant(ancestorId, potentialDescendant.parent);
            }

            renderEditors() {
                const container = document.getElementById('editor-container');
                const contentTitle = document.getElementById('content-title');

                if (this.selectedNotes.length === 0) {
                    contentTitle.textContent = 'Select a note to edit';
                    container.innerHTML = '<div class="editor"><div class="line-numbers">1</div><textarea class="editor-textarea" placeholder="Select a note to start writing..."></textarea></div>';
                    return;
                }

                if (this.selectedNotes.length === 1) {
                    const note = this.notes[this.selectedNotes[0]];
                    contentTitle.textContent = note ? note.title : 'Note not found';
                } else {
                    contentTitle.textContent = `${this.selectedNotes.length} notes selected`;
                }

                container.innerHTML = '';

                this.selectedNotes.forEach((noteId, index) => {
                    const note = this.notes[noteId];
                    if (!note) return;

                    const editor = document.createElement('div');
                    editor.className = 'editor';
                    
                    const lineNumbers = document.createElement('div');
                    lineNumbers.className = 'line-numbers';
                    lineNumbers.id = `line-numbers-${index + 1}`;
                    
                    const textarea = document.createElement('textarea');
                    textarea.className = 'editor-textarea';
                    textarea.id = `editor-${index + 1}`;
                    textarea.value = note.content;
                    textarea.placeholder = `Editing: ${note.title}`;

                    textarea.oninput = () => {
                        note.content = textarea.value;
                        this.markUnsaved();
                        this.updateLineNumbers(`editor-${index + 1}`, `line-numbers-${index + 1}`);
                    };

                    editor.appendChild(lineNumbers);
                    editor.appendChild(textarea);
                    container.appendChild(editor);

                    // Initialize line numbers
                    setTimeout(() => this.updateLineNumbers(`editor-${index + 1}`, `line-numbers-${index + 1}`), 0);
                });
            }

            exportData() {
                const data = {
                    notes: this.notes,
                    nextId: this.nextId,
                    exportDate: new Date().toISOString()
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `nested-notes-${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                this.markSaved();
            }

            importData() {
                document.getElementById('file-input').click();
            }

            handleFileImport(file) {
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        if (data.notes && typeof data.notes === 'object') {
                            if (confirm('This will replace all current notes. Continue?')) {
                                this.notes = data.notes;
                                this.nextId = data.nextId || Math.max(...Object.keys(data.notes).map(Number)) + 1;
                                this.selectedNotes = [];
                                this.markSaved();
                                this.render();
                            }
                        } else {
                            alert('Invalid file format');
                        }
                    } catch (error) {
                        alert('Error reading file: ' + error.message);
                    }
                };
                reader.readAsText(file);
            }

            printNotes() {
                window.print();
            }
        }

        // Global functions
        function toggleTheme() {
            const body = document.body;
            const currentTheme = body.getAttribute('data-theme');
            body.setAttribute('data-theme', currentTheme === 'dark' ? 'light' : 'dark');
        }

        function addNote() {
            app.addNote();
        }

        function exportData() {
            app.exportData();
        }

        function importData() {
            app.importData();
        }

        function printNotes() {
            app.printNotes();
        }

        // Initialize app
        const app = new NestedNotes();
    </script>
</body>
</html>